# Project plan

## Start-up phase
<!--
Covering the planning phase, this section should provide a relatively detailed plan of how work will start on the project. This section is important because projects need to get up and running quickly.


 - [ ] Setting up collaboration platform inc. code for contributors etc.
 - [ ] Licence decisions
 - [ ] Reporting framework
-->

Collaboration platform:

  * GitLab in the lab; synchronized on public [GitHub
    repository](https://github.com/mablab/sftraj) (already available)
  * Code of conduct (from rOpenSci)
  * License: MIT, to allow wide acceptation by other package
    developers

### Use cases

* `trackeR` model (from Ioannis Kosmidis)

Overall, what our `trackeRdata` object does and what I guess I would
expect by a new object that sets the standards for (2D–3D) trajectory
data is that the object:

  * can carry /all available movement information/ that have been
    recorded (time, lon, lat, speed, distance, altitude)
  * have methods that allow the user to
    - infer speed from distance and time (and elevation for 3D)
    - infer distance from speed and time (and elevation for 3D)
    - infer distance and speed from time, lon, lat, altitude (and
      elevation for 3D)
    - impute speed/distance from past/future observations if time,
      lon, lat are missing (speeds in humans are extremely predictable
      from past/future speed and I guess the same is true for many
      types of trajectory data)
    - correct altitude data (for 2D)
    - correct coordinate data (by smoothing)
  * is unit-aware (for speed, distance, altitude) and allows changing
    those units
  * allows for extra variables (e.g. power, cadence and the likes in
    the context of athlete trajectories) that are recorded at
    timestamp level
  * allow for variables that are recorded at trajectory level
    (e.g. athlete name and sport in `trackeR` case), /without/ having
    to repeat that over all timestamps in a trajectory; so here a
    single `tibble` for each trajectory is not a good idea, I think.


## Technical delivery
<!--
Covering the actual delivery of the project this section should provide at least a high-level the implementation. 

Including target dates is really important as you need to be committed and the ISC need to have a means of tracking delivery
-->

We use the MoSCoW method to determine what will be delivered from this
project, starting from a minimum viable product to future development:

  * **Must have** (requirements necessary for project completion,
    i.e. the minimum viable product)
    * Use cases defined [July]
    * Class(es) definition [August]
    * Creators and converters from basic objects (`data.frames`, `sf`,
      `sftraj`) [September]
    * Accessors and summaries (`print`, `summary`) [October]
    * Full function documentation [October–November]
    * Installable package (GitHub) [September–December]
  * **Should have** (important requirements not necesary for project
    completion):
    * Vignette [November]
    * CRAN package [December]
  * **Could have** (desirable requirements developed if time allows):
    * Basic plot (static)
  * **Won't have** (requirements that are not planned at this stage):
    * See section on *Future work*.


## Other aspects
<!--
Covering non-technical activities like on-going publicity, paper preparation, discussion groups etc. that might be required to facilitate successful delivery of the project.

 - [ ] Announcement post
 - [ ] Delivery blog post
 - [ ] Twitter
 - [ ] UseR!
 - [ ] ISC meetings
-->

We will adopt a "release early, release often" philosophy, where we
publicly provide developments of new ideas and functions. This will
come hand in hand with regular blog posts on the [MabLab
website](https://mablab.org/) to communicate progress (basically for
each deliverable), and constant communication on Twitter by the core
team.
